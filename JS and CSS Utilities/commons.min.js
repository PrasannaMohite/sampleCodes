function fixProgressIndicator(){
	$( "#guideContainerForm .wizard-navigators" ).wrap( "<div class='breadcrumb-navigators'></div>" );
}
function throttle(time, func) {
  if (!time || typeof time !== "number" || time < 0) {
      return func;
  }
  var throttleTimer = 0;
  return function() {
    var args = arguments;
    clearTimeout(throttleTimer);
    throttleTimer = setTimeout(function() {
      func.apply(null, args);
    }, time);
  }
}
/**
 *   Makes REST API call
 **/
function makeRestAPICall(securityEnabled, restURI, method, data, inputType, outputType, beforeSendCallBack, afterSendCallBack, successCallBack, errorCallBack){
    if("true" === securityEnabled){
        invokeRestAPIWithDataSecurity(restURI, method, data, inputType, outputType, beforeSendCallBack, afterSendCallBack, successCallBack, errorCallBack);
    }else{
        $.ajax({
            type: method,
            url: restURI,
            cache: false,
            data: JSON.stringify(data),
            beforeSend: beforeSendCallBack(),
            contentType: inputType,
            dataType: outputType,
            success: function (jsonResponseObj) {
                afterSendCallBack();
                successCallBack(jsonResponseObj);
            },
            error: function (errorObj, exception) {
                afterSendCallBack();
                errorCallBack(errorObj, exception);
            }
        });

    }
}
/*
 * Convert a string into an array buffer
 */
function stringToArrayBuffer(str) {
	const buf = new ArrayBuffer(str.length);
	const bufView = new Uint8Array(buf);
	for (var i = 0, strLen = str.length; i < strLen; i++) {
		bufView[i] = str.charCodeAt(i);
	}
	return buf;
}

/*
 * convert array buffer to string
 */
function arrayBufferToString(str) {
	var byteArray = new Uint8Array(str);
	var byteString = '';
	for (var i = 0; i < byteArray.byteLength; i++) {
		byteString += String.fromCharCode(byteArray[i]);
	}
	return byteString;
}

function isStringEmpty(str) {
	return (!str || 0 === str.length);
}

/**
 * Initialization 
 */
function initRestAPIDataSecurityService(publicKeyPemContent) {
	if (restAPIDataSecurityServiceContext.supportsES6) {
		initRestAPIDataSecurityServiceES6(publicKeyPemContent);
	} else {
		initRestAPIDataSecurityServiceNoES6(publicKeyPemContent);
	}
}

/**
 * Encrypts data and invokes the callbacks
 */
function encryptData(data, successCallback, errorCallback) {
	try {
		if (restAPIDataSecurityServiceContext.initStatus) {
			if (restAPIDataSecurityServiceContext.supportsES6) {
				encryptDataES6((isStringEmpty(data) ? " " : data), successCallback, errorCallback);
			} else {
				encryptDataNoES6((isStringEmpty(data) ? " " : data), successCallback, errorCallback);
			}
		} else {
			errorCallback('DataEncryptionService not initialized');
		}
	} catch (errorObj) {
		if (errorCallback) {
			errorCallback(errorObj);
		}
	}
}


/**
 * Decrypts data and invokes the callbacks
 */
function decryptData(encData, secret, successCallback, errorCallback) {
	try {
       if (restAPIDataSecurityServiceContext.initStatus) {
	         //Proceed if data is not empty
             if(!isStringEmpty(encData)){
                if (restAPIDataSecurityServiceContext.supportsES6) {
                    decryptDataES6(encData, secret, successCallback, errorCallback);
                } else {
                    decryptDataNoES6(encData, secret, successCallback, errorCallback);
                }
            } else{
               successCallback(encData);
            }
       }else {
          errorCallback('DataEncryptionService not initialized');
       }
    } catch (errorObj) {
		if (errorCallback) {
			errorCallback(errorObj);
		}
	}
}


/**
 * Initialization in browsers where ES6 is supported 
 */
function initRestAPIDataSecurityServiceES6(publicKeyPemContent) {
	//Base64 decode
	var binaryDerString = atob(publicKeyPemContent);
   	// convert from a binary string to an ArrayBuffer
	var binaryDer = stringToArrayBuffer(binaryDerString);
	// Import asymmetric public key
	restAPIDataSecurityServiceContext.crypto.subtle.importKey("spki", binaryDer, {
		name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
		hash: restAPIDataSecurityServiceContext.digestAlgo
	}, true, ["encrypt"]).then(function (publicKey) {
		restAPIDataSecurityServiceContext.aSymmetricPublicKey = publicKey;
		//Creates the symmteric key
		restAPIDataSecurityServiceContext.crypto.subtle.generateKey({
			name: restAPIDataSecurityServiceContext.symmetricAlgo,
			length: restAPIDataSecurityServiceContext.symmetricKeyLength
		}, true, ["encrypt", "decrypt"]).then(function (symKey) {
			restAPIDataSecurityServiceContext.symmetricKey = symKey;
			//Export the symmetric key for further use
			restAPIDataSecurityServiceContext.crypto.subtle.exportKey("raw", restAPIDataSecurityServiceContext.symmetricKey).then(function (symKeyData) {
				var symmetricKeyData = symKeyData;
				//Encrypting the symmetric key with assymetric key		
				restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
					name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
					hash: {
						name: restAPIDataSecurityServiceContext.digestAlgo
					}
				}, restAPIDataSecurityServiceContext.aSymmetricPublicKey, symmetricKeyData).then(function (encSymmetricKeyBuf) {
					restAPIDataSecurityServiceContext.encSymmetricKey = btoa(arrayBufferToString(encSymmetricKeyBuf));
					//Mark the initialization status
					restAPIDataSecurityServiceContext.initStatus = true;
				}); //Encrypt symmetric key with asymmetric public key
			}); //Export symmetric key
		}); //Generate symmetric key   	
    }); //Import asymmetric public key
}

/**
 * Encrypts data
 */
function encryptDataES6(data, successCallback, errorCallback) {
	var secret = restAPIDataSecurityServiceContext.crypto.getRandomValues(new Uint8Array(restAPIDataSecurityServiceContext.secretLength));
	var dataBuf = stringToArrayBuffer(data);
	restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
		name: restAPIDataSecurityServiceContext.symmetricAlgo,
		iv: secret,
		tagLength: restAPIDataSecurityServiceContext.secretTagLength
	}, restAPIDataSecurityServiceContext.symmetricKey, dataBuf).then(function (dataEncBuf) {
		var dataEnc = btoa(arrayBufferToString(dataEncBuf));
		restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
			name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
			hash: {
				name: restAPIDataSecurityServiceContext.digestAlgo
			}
		}, restAPIDataSecurityServiceContext.aSymmetricPublicKey, secret).then(function (encSecretBuf) {
			var encSecret = btoa(arrayBufferToString(encSecretBuf));
			successCallback({
				"dataEnc": dataEnc,
				"secret": secret,
				"secretEnc": encSecret,
				"keyEnc": restAPIDataSecurityServiceContext.encSymmetricKey
			});
		}).catch(function (error) {
			errorCallback(error);
		}); //Encrypt random IV
	}).catch(function (error) {
		errorCallback(error);
	}); //Encrypt data
}

/**
 * Decrypts data
 */
function decryptDataES6(encData, secret, successCallback, errorCallback) {
	var encDataBuf = stringToArrayBuffer(atob(encData));
	restAPIDataSecurityServiceContext.crypto.subtle.decrypt({
		name: restAPIDataSecurityServiceContext.symmetricAlgo,
		iv: secret,
		tagLength: restAPIDataSecurityServiceContext.secretTagLength
	}, restAPIDataSecurityServiceContext.symmetricKey, encDataBuf).then(function (dataEncBuf) {
		var decData = arrayBufferToString(dataEncBuf);
		successCallback(decData);
	}).catch(function (error) {
		errorCallback(error);
	}); //Decrypt data
}

/**
 * Initialization in IE11 browser 
 */
function initRestAPIDataSecurityServiceNoES6(publicKeyPemContent) {
	var binaryDerString = atob(publicKeyPemContent);
	// convert from a binary string to an ArrayBuffer
	var binaryDer = stringToArrayBuffer(binaryDerString);
	// Import asymmetric public key
	var pubKeyOperation = restAPIDataSecurityServiceContext.crypto.subtle.importKey("spki", binaryDer, {
		name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
		hash: restAPIDataSecurityServiceContext.digestAlgo
	}, true, ["encrypt"]);
	pubKeyOperation.oncomplete = function (evt) {
		restAPIDataSecurityServiceContext.aSymmetricPublicKey = evt.target.result;
		//Creates the symmteric key
		var symKeyOperation = restAPIDataSecurityServiceContext.crypto.subtle.generateKey({
			name: restAPIDataSecurityServiceContext.symmetricAlgo,
			length: restAPIDataSecurityServiceContext.symmetricKeyLength
		}, true, ["encrypt", "decrypt"]);
		symKeyOperation.oncomplete = function (evt) {
			restAPIDataSecurityServiceContext.symmetricKey = evt.target.result;
			//Export the symmetric key for further use
			var exportSymKeyOperation = restAPIDataSecurityServiceContext.crypto.subtle.exportKey("raw", restAPIDataSecurityServiceContext.symmetricKey);
			exportSymKeyOperation.oncomplete = function (evt) {
				var symmetricKeyData = evt.target.result;
				//Encrypting the symmetric key with assymetric key		
				var encSymKeyOperation = restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
					name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
					hash: {
						name: restAPIDataSecurityServiceContext.digestAlgo
					}
				}, restAPIDataSecurityServiceContext.aSymmetricPublicKey, symmetricKeyData);
				encSymKeyOperation.oncomplete = function (evt) {
					restAPIDataSecurityServiceContext.encSymmetricKey = btoa(arrayBufferToString(evt.target.result));
					//Mark the initialization status
					restAPIDataSecurityServiceContext.initStatus = true;
				}; //Encrypt symmetric key with asymmetric public key
			}; //Export symmetric key
		}; //Generate symmetric key   	
	}; //Import asymmetric public key
}
/**
 * Encrypts data
 */
function encryptDataNoES6(data, successCallback, errorCallback) {
	var secret = restAPIDataSecurityServiceContext.crypto.getRandomValues(new Uint8Array(restAPIDataSecurityServiceContext.secretLength));
	var dataBuf = stringToArrayBuffer(data);
	//Symmetric encryption of data
	var encDataOperation = restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
		name: restAPIDataSecurityServiceContext.symmetricAlgo,
		iv: secret,
		tagLength: restAPIDataSecurityServiceContext.secretTagLength
	}, restAPIDataSecurityServiceContext.symmetricKey, dataBuf);
	encDataOperation.oncomplete = function (evt) {
		//Add the tag to the end of cypher text
		var secretTag = evt.target.result.tag;
		var cyperText = evt.target.result.ciphertext;
		var dataEncBuf = new Uint8Array(dataBuf.byteLength + (restAPIDataSecurityServiceContext.secretTagLength / 8));
		dataEncBuf.set(new Uint8Array(cyperText), 0);
		dataEncBuf.set(new Uint8Array(secretTag), dataBuf.byteLength);
		var dataEnc = btoa(arrayBufferToString(dataEncBuf));
		//Encrypt the secret
		var encSecretOperation = restAPIDataSecurityServiceContext.crypto.subtle.encrypt({
			name: restAPIDataSecurityServiceContext.aSymmetricAlgo,
			hash: {
				name: restAPIDataSecurityServiceContext.digestAlgo
			}
		}, restAPIDataSecurityServiceContext.aSymmetricPublicKey, secret);
		encSecretOperation.oncomplete = function (evt) {
			var encSecret = btoa(arrayBufferToString(evt.target.result));
			successCallback({
				"dataEnc": dataEnc,
				"secret": secret,
				"secretEnc": encSecret,
				"keyEnc": restAPIDataSecurityServiceContext.encSymmetricKey
			});
		}; //Encrypt secret success
		encSecretOperation.onerror = function (error) {
			errorCallback(error);
		}; //Encrypt secret error
	}; //Encrypt data success
	encDataOperation.onerror = function (error) {
		errorCallback(error);
	}; //Encrypt data error
}


/**
 * Decrypts data
 * var cText;
 * var tag;
 * var iv;
 */
function decryptDataNoES6(encData, secret, successCallback, errorCallback) {
	var encDataBuf = stringToArrayBuffer(atob(encData));
	var encDataBufLen = encDataBuf.byteLength;
	var tagLen = restAPIDataSecurityServiceContext.secretTagLength / 8;
	var cyperText = [];
	var secretTag = encDataBuf;
	//Extract the tag and cypher text
	if (encDataBufLen >= tagLen) {
		cyperText = encDataBuf.slice(0, (encDataBufLen - tagLen));
		secretTag = encDataBuf.slice((encDataBufLen - tagLen), encDataBufLen);
	}
	var decryptOperation = restAPIDataSecurityServiceContext.crypto.subtle.decrypt({
		name: restAPIDataSecurityServiceContext.symmetricAlgo,
		iv: secret,
		tagLength: restAPIDataSecurityServiceContext.secretTagLength,
		tag: secretTag
	}, restAPIDataSecurityServiceContext.symmetricKey, cyperText);
	decryptOperation.oncomplete = function (evt) {
		var decData = arrayBufferToString(evt.target.result);
		successCallback(decData);
	}; //Decrypt data success
	decryptOperation.onerror = function (error) {
		errorCallback(error);
	}; //Decrypt data error
}

/**
 * Helper function to API invocation error
 */
function handleAPIInvocationFailure(postExecutionCallback, errorCallback, errorObj) {
	if (postExecutionCallback) {
		postExecutionCallback();
	}
	if (errorCallback) {
		errorCallback(errorObj);
	}
}

/**
 * Helper function to handle data invocation success
 */
function handleAPIInvocationSuccess(postExecutionCallback, successCallBack, data, outputType) {
	if (postExecutionCallback) {
		postExecutionCallback();
	}
	if (successCallBack) {
		successCallBack(("json" === outputType && !isStringEmpty(data)) ? JSON.parse(data) : data);
	}
}

/**
 * Helper function to perform pre-API invocation operations
 */
function performPreAPIInvocationOperations(preExecutionCallback, data, inputType) {
	if (preExecutionCallback) {
		preExecutionCallback();
	}
	return ("application/json" === inputType && !isStringEmpty(data)) ? JSON.stringify(data) : data;
}

/**
 * Prepares the request headers
 */
function getDataEncRequestHeaders(encDataPack) {
	var requestHeaders = {};
	requestHeaders[restAPIDataSecurityServiceContext.SEC_KEY_HEADER] = encDataPack.keyEnc;
	requestHeaders[restAPIDataSecurityServiceContext.SEC_SECRET_HEADER] = encDataPack.secretEnc;
	return requestHeaders;
}

/**
 * Encrypts the input and decrypts the output and passes to caller 
 */
function invokeRestAPIWithDataSecurity(restURI, method, data, inputType, outputType, preExecutionCallback, postExecutionCallback, successCallBack, errorCallback) {
	var dataStr = performPreAPIInvocationOperations(preExecutionCallback, data, inputType);
	try {
		//Handle encryption and decryption if supported
		if(restAPIDataSecurityServiceContext.initStatus){
			//Encrypt the data
			encryptData(dataStr, function (encDataPack) {
				//Build headers
				var requestHeaders = getDataEncRequestHeaders(encDataPack);
				//Make the actual AJAX call
				$.ajax({
					headers: requestHeaders,
					type: method,
					url: restURI,
					cache: false,
					data: encDataPack.dataEnc,
					contentType: "text/plain",
					dataType: 'text',
					success: function (responseObj) {
                       //Decrypt the data
						decryptData(responseObj, encDataPack.secret, function (decData) {
                        	handleAPIInvocationSuccess(postExecutionCallback, successCallBack, decData, outputType);
						}, function (errorObj) {
                        	handleAPIInvocationFailure(postExecutionCallback, errorCallback, errorObj);
						}); //Decryption error
					},
					error: function (errorObj) {
						handleAPIInvocationFailure(postExecutionCallback, errorCallback, errorObj);
					} //AjaxDecryption error
				}); //Ajax call
			}, function (errorObj) {
				handleAPIInvocationFailure(postExecutionCallback, errorCallback, errorObj);
			}); // Encryption error
		}else{  //Byepass encryption
				$.ajax({
					type: method,
					url: restURI,
					cache: false,
					data: dataStr,
					contentType: inputType,
					dataType: outputType,
					success: function (responseObj) {
                        if (postExecutionCallback) {
							postExecutionCallback();
						}
                        successCallBack(responseObj);
   		            },
					error: function (errorObj) {
                      handleAPIInvocationFailure(postExecutionCallback, errorCallback, errorObj);
					} //AjaxDecryption error
				}); //Ajax call
		}
	} catch (errorObj) {
		handleDataEncFailure(postExecutionCallback, errorCallback, errorObj);
	}
}

var restAPIDataSecurityServiceContext = {
	"SEC_KEY_HEADER": "X-ENCKEY",
	"SEC_SECRET_HEADER": "X-ENCSECRET",
	"crypto": (window.crypto || window.msCrypto),
	"supportsES6": (window.msCrypto ? false : true),
	"symmetricAlgo": "AES-GCM",
	"symmetricKeyLength": 256,
	"secretLength": 12, //IV length
	"secretTagLength": 128, //GCM tag length
	"aSymmetricAlgo": "RSA-OAEP",
	"digestAlgo": "SHA-256",
	"initStatus": false,
	"symmetricKey": null,
	"encSymmetricKey": null,
	"aSymmetricPublicKey": null
}
